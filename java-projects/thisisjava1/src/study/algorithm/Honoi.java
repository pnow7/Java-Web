package study.algorithm;

/*
세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 
각 원판은 반경이 큰 순서대로 쌓여있다. 
이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.
이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 
단, 이동 횟수는 최소가 되어야 한다.

[입력]
3(원판의 개수 N)

[출력]
7(옮긴 횟수 K를 출력)
1 3
1 2
3 2
1 3
2 1
2 3
1 3

*/

/*
N : 원판의 개수
start : 출발지
mid : 옮기기 위해 이동해야 장소
end : 목적지
*/

import java.io.*;

public class Honoi {
	
	static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int N = Integer.parseInt(br.readLine());
		
		sb.append((int)(Math.pow(2, N) -1)).append("\n");
		
		Honoi(N, 1, 2, 3);
		System.out.println(sb);

	}
	
	static void Honoi(int N, int start, int mid, int end) {
		if(N == 1) {
			sb.append(start + " " + end + "\n");
			return;
		}
		// start -> end로 옮긴다고 가정할 떄,
		
		//N-1개를 start에서 mid로 이동 (= start 지점의 N-1개의 원판을 mid 지점으로 옮긴다.)
		Honoi(N-1, start, end, mid);
		
		//1개를 start에서 end로 이동(= start 지점의 N번재 원판을 to 점으로 옮긴다.)
		sb.append(start + " " + end + "\n");
		
		//N-1개를 mid에서 end로 이동(= mid 지점의 N-1개의 원판을 to 지점으로 옮긴다.)
		Honoi(N-1, mid, start, end);
	}

}


/*

------------------------------------------------------------

1. 가장 큰 원판을 C 로 옮기기 위해서는 n-1 개의 원판이 A 에서 B 로 가야한다.
물론 n-1 번만큼 B 로 이동하기 위한 같은 반복을 할 것이다.
즉 A 에서 B로 가는 것을 Hanoi 함수라고 한다면, n-1 개만큼 반복한다는 의미다.
즉, 이동 횟수는 Hanoi(n-1) 이다.


2. 그리고 A 에 있는 가장 큰 원판이 C 로 이동할 것이다.
이 이동은 가장 큰 원판만 이동하기 때문에 횟수는 1 회가 되겠다.

3. B 에 있는 (n-1)개의 원판을 C 로 이동한다.
앞서 A 에서 B 로 n-1 개가 이동했듯이, B 에서 C 로 이동하는 횟수는 Hanoi(n-1) 가 된다.



n 개의 원판을 이동시키기 위해 Hanoi(n-1) 횟수만큼 이동한 횟수가 2번이고,

가장 아래 원판은 1번 이동하였으므로 공식화 하면 아래와 같다.

Hanoi(n) = 2 × Hanoi(n-1) + 1


𝑛개의 원판을 이동시키기 위한 이동 횟수를 𝑎𝑛 이라고 할 때, 
n개의 원판을 옮기려면 그 위 쪽에 있는 (n-1)개의 원판을 모두 다른 막대로 옮긴 후, 
맨 아래 원판을 빈 막대로 옮긴 다음에 그 위에 (n-1)개의 원판을 옮겨놓아야 한다.

𝑎𝑛+1 의 경우를 보면,

1. 가장 큰 𝑛 번째 원판을 옮기기 위해 𝑛-1 개의 원판을 옮겨야 한다. 이 때 𝑛 개의 원판이 A 에서 B 로 이동하는 경우는 𝑎𝑛-1 이다.

2. 𝑛 번째 원판을 A 에서 C 로 옮기는 경우는 1 이다.

3. B에 있는 n개의 원판이 C로 옮기는 경우는 𝑎𝑛-1 이다.


이 것을 수식화 하면 다음과 같다.

a𝑛 = a𝑛-1 + 1 + a𝑛-1 이다.

즉, 원판이 이동하는 점화식은 a𝑛 = 2×a𝑛 - 1 + 1 이다.

 

위 점화식에서 양 변에 1을 더해 우변을 다음과 같이 묶어줄 수 있다.

a𝑛 + 1 = 2(a𝑛 + 1)

그리고 임의이 b𝑛을 다음과 같이 정의해보자
b𝑛 = a𝑛 + 1 이면

b𝑛+1 = 2b𝑛
공비가 2

그리고 b𝑛의 첫째항 즉 b1dms a1 = 1이 었으므로
b1 = a1 + 1 = 2

즉 첫째항은 2, 공비는 2인 공비수열

b𝑛 = a𝑛 + 1 = 2^n

# a𝑛 = 2^n - 1

이 공식의 일반항은 a𝑛 = 2^n - 1


일단 재귀를 통해 가장 작은 단위로 들어간다.

즉, 먼저

A 에서 B 로 원판을 이동하는 경우의

    A 에서 B 로 원판을 이동하는 경우의

        A 에서 B 로 원판을 이동하는 경우의
      				...
      				
이렇게 계속 A 에서 B로 이동하는 함수를 재귀호출하여 
이동해야 할 원판이 1개가 되면 
그 때 A 에서 B로 이동했다는 것을 출력한 뒤, 함수를 리턴하면 된다.

그렇게 원판이 1개일 때 A 에서 B로 이동한 함수가 닫히면

그 전 단계 재귀로 다시 돌아오면 원판이 2개일 때가 된다. 
이때는 앞서 그림에서 봤듯이 1개의 원판이 A 에서 C로 이동하면 되므로, 
이 때의 경우를 출력한다.


출력이 끝나면, B 에서 C 로 이동하도록 다시 재귀호출을 한다.

*/
